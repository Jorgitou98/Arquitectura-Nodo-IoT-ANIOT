3. Propón varias alternativas de diseño: ¿Cuántas tareas? ¿Creando un único timer para todos o usando un timer para cada muestreo/LED?¿Usando eventos?¿Usando colas para el paso de mensajes entre tareas?

Para empezar, resumimos nuestro diseño antes de proponer alternativas (el enunciado decía lo que había que hacer, pero no cómo había que implementarlo). Nuestro implementación utiliza una cola (expuesta en "communication_utils.h") para enviar tanto la información de nuevas muestras (de distancia o del sensor de hall), como el valor del contador cuando se modifica. Además, utiliza un evento para informar cuando el contador ha sido resetado como consecuencia de pulsar el botón. Hemos elegido este diseño porque los eventos, como interrupciones asíncronas que son, están pensados para atender rápidamente un suceso que pueda producirse en cualquier momento. Los eventos no están para comunicar información que se genera periódicamente; para eso están las colas. Como el pulsado del botón es algo que puede suceder en cualquier momento, hemos decidido comunicarlo mediante un evento. Debido a que el muestreo de los sensores y la modificación del contador son procesos periódicos orientados a producir datos, hemos decidido utilizar una cola de punteros a estructura para ellos. Dicha estructura lleva un campo enumerado con el tipo de mensaje (para que el receptor pueda interpretar adecuadamente la información) y un valor con el dato enviado (de tipo void* para que pueda ser cualquier cosa).

Una posible alternativa, que nos parece peor que nuestra solución, es utilizar también eventos para comunicar las muestras de los sensores y el valor del contador modificado. Nos parece que es "matar moscas a cañonazos", pues básicamente estamos interrupiendo asíncronamente una tarea para enviar un dato que se genera periódicamente. Los eventos no están pensados para este tipo de situaciones. Realmente no queremos avisar de nada asíncrono (el suceso es periódico y conocido), sino pasar el nuevo dato para que se consuma.

Otra alternativa es utilizar también la cola para informar del reseteo del botón. Podríamos mandar un puntero a la estructura indicando el reseteo mediante el campo del tipo de mensaje (dejando a NULL el campo del valor). Con ello, utilizaríamos también la cola para hacer avisos (sin enviar datos) y nos ahorraríamos el uso de eventos en la aplicación. No obstante, el pulsado del botón que desencadena el reseteo sí es un evento asíncrono que sería más correcto representar mediante los eventos de usuario de ESP-IDF (por eso lo hemos hecho así).

Nuestra aplicación utiliza un timer propio para cada muestreador y otro para el contador, con un periodo diferente y configurable mediante menuconfig para cada uno (esta nos parece la solución más flexible). También podríamos tener un único timer para los dos sensores y el contador, o un timer para los dos sensores y otro para el contador, o un timer para un sensor-contador y otro para el sensor restante. Las opciones son muchas y la decisión dependerá de las necesidades concretas de la aplicación. Reutilizando timers, reducimos el número de tareas (cada timer se está creando con una tarea asociada), pero perdemos flexibilidad: hay que utilizar el mismo periodo para varios sensores/contadores. Quizás nos interesa tener distintos periodos porque la magnitud que mide un sensor cambia mucho más rápido que la que mide otro. No obstante, es buena idea utilizar el mismo timer para aquellos sensores que sepamos con seguridad que deben muestrearse con la misma frecuencia y que siempre van a utilizar juntos (si arrancamos/paramos el muestreo de un sensor también queremos que lo haga el de otro).
